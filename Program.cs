using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using VDap.Task6.Events;
using VDap.Task6.ThreadPoolElements;
using static VDap.Task6.CustomThreadPool;

namespace VDap.Task6
{
    public class Program
    {
        static CustomThreadPool threadpool = CustomThreadPool.GetThreadPool(PoolStructure.Queue);
        static string result;
        static int value = 11;
        static int key = 0;
        static void Main(string[] args)
        {
            string goalKey = "20";
            Tree tree = generateTree(6);//Tree is generated by going in depth from left
            (Tree, string) data = (tree, goalKey);
            Stopwatch timer = new Stopwatch();
            timer.Start();
            threadpool.AddTask(performSearch, data,Priority.Normal, TaskException, TaskCompletion);
            timer.Stop();
            Console.WriteLine($"Elapsed time in parallel execution :{timer.Elapsed}");
            timer.Restart();
            result = string.Empty;
            performSearchSequential(tree,goalKey);
            timer.Stop();
            Console.WriteLine($"Elapsed time in sequential execution : {timer.Elapsed}");
            Console.ReadKey();
        }
        private static Tree generateTree(int depth)
        {
            Tree tree = new Tree();
            if (depth > 0)
            {
                ++value;
                ++key;
                tree = new Tree() { 
                    Key = key.ToString(), 
                    Value = value.ToString(), 
                    LeftNode = generateTree(depth - 1), 
                    RightNode = generateTree(depth - 1) };
                return tree;
            }
            else
            {
                return null;
            }
        }
        private static void performSearch(object data)
        {
            Tree tree = ((ValueTuple<Tree,string>)data).Item1;
            string goalKey = ((ValueTuple<Tree,string>)data).Item2;
            if (tree != null)
            {
                if (tree.Key != null && tree.Key == goalKey)
                {
                    threadpool.CancelAll();
                    result = tree.Value;
                    Console.WriteLine($"Goal key in parallel mode is : {tree.Key} and it's value is :{result}");
                }
                else
                {
                    if (tree.LeftNode != null)
                    {
                        (Tree,string) leftNode = (tree.LeftNode,goalKey);
                        threadpool.AddTask(performSearch, leftNode, Priority.Normal, TaskException, TaskCompletion);
                    }
                    if (tree.RightNode != null)
                    {
                        (Tree,string) rightNode = (tree.RightNode,goalKey);
                        threadpool.AddTask(performSearch, rightNode, Priority.Normal, TaskException, TaskCompletion);
                    }
                }
            }
            else if(tree.Key != null)
                Console.WriteLine("The goal key is not in the tree");
            return;
        }
        private static void performSearchSequential(Tree tree,string goalKey)
        {
            if (tree != null)
            {
                if (tree.Key != null && tree.Key.Equals(goalKey))
                {
                    result = tree.Value;
                    Console.WriteLine($"Goal key is : {tree.Key} and it's value is :{result}");
                }
                else
                {
                    if (tree.LeftNode != null)
                    {
                        performSearchSequential(tree.LeftNode,goalKey);
                    }
                    if (tree.RightNode != null)
                    {
                        performSearchSequential(tree.RightNode,goalKey);
                    }
                }
            }
            else if (tree.Key != null)
                Console.WriteLine("The goal key is not in the tree");
            return;
        }
        static void TaskCompletion(object sender,CompletedTaskEventArgs args)
        {
            Console.WriteLine("Task " + args.Token + "is done" + "data is " + args.UserData);
        }
        static void TaskException(object sender, UserExceptionEventArgs args)
        {
            Console.WriteLine("Task " + args.Token + " has exception" + "data is "+args.UserData);
        }
    }
    
}
